<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://awolski.com/style.css><title>Using Docker to spin up databases for development | Tony Wolski</title><meta name=description content="Tony Wolski: Using Docker to spin up production-like databases during application development can help take out the uncertainty of whether your changes will work when â€¦"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=referrer content="no-referrer"><meta name=generator content="Hugo 0.69.0"><link rel=canonical href=https://awolski.com/using-docker-to-spin-up-databases-for-development/></head><body><section id=masthead><h1><a href=/ title="Tony Wolski">Tony Wolski</a></h1><nav><ul><li><a href=/contact title=Contact>Contact</a></li></ul></nav></section><div id=content><article class=post><header><h1>Using Docker to spin up databases for development</h1><small>2015-05-19</small></header><p>Using Docker to spin up production-like databases during application development can help take out the uncertainty of whether your changes will work when deployed to production. In this post, I&rsquo;ll show you how I use Docker to create a clean MySQL database that mirrors production each time a start development on a new feature.</p><p>Have you ever been developing something for a long period of time, making changes to your development database as you go, and then when you&rsquo;ve gone to integrate it into staging or production things haven&rsquo;t quite worked? You&rsquo;ve had to manually write scripts to &lsquo;fix&rsquo; things, or try and get back to your clean development database state by exporting, copying and importing&mldr; all manually via your database client?</p><p>If this sounds like you (as it did me), you&rsquo;ll be pleased to know there are better ways to manage your development database workflow.</p><p>I user <a href=https://www.docker.com/>Docker</a> (specifically <a href=https://docs.docker.com/machine/>Docker Machine</a>), to spin up clean MySQL instances, and with a few commands have a production-like database to develop against. And the best part about my workflow is that I don&rsquo;t have to install MySQL on my laptop or have numerous schemas floating around. If I want to remove what I&rsquo;ve been doing and start afresh, all I have to do is stop and remove the containers I&rsquo;ve been working with.</p><p>Here&rsquo;s how I do it:</p><p>First create or restart a VM using Docker Machine:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker-machine create --driver virtualbox dev<span style=color:#e6db74>`</span> or <span style=color:#e6db74>`</span>docker-machine restart dev<span style=color:#e6db74>`</span>
</code></pre></div><p>Then set your machine as the one you&rsquo;ll be using:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker-machine env dev
export DOCKER_TLS_VERIFY<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
export DOCKER_CERT_PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/Users/awolski/.docker/machine/machines/dev&#34;</span>
export DOCKER_HOST<span style=color:#f92672>=</span>tcp://192.168.99.100:2376
<span style=color:#75715e># Run this command to configure your shell: eval &#34;$(docker-machine env dev)&#34;</span>
$ eval <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>docker-machine env dev<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><p>This will let you run <code>docker</code> from the command line which will be run against your dev machine.</p><p>Next, create a mysql data container to store our data:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker create -v /var/lib/mysql --name my-database mysql  /bin/true
6e144f951abb32fa985353c42ad0c46b629da0e2f4f367aa724b526dfbe752b8
</code></pre></div><p>We can check that the container was created with <code>docker ps -all</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker ps -all
CONTAINER ID    IMAGE         ...  NAMES
6e144f951abb    mysql:latest  ...  my-database
</code></pre></div><p>Now start a MySQL container, exposing the port (so that we can connect from the host machine) and mounting the data container with the <code>--volumes-from</code> argument:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker run --name mysql -e MYSQL_ROOT_PASSWORD<span style=color:#f92672>=</span>password -p 3306:3306 --volumes-from my-database -d mysql<span style=color:#e6db74>`</span>
</code></pre></div><p>You should now see that the container is up and running:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker ps
CONTAINER ID    IMAGE         STATUS        PORTS                   NAMES
600ed53340ab    mysql:latest  Up <span style=color:#ae81ff>4</span> minutes  0.0.0.0:3306-&gt;3306/tcp  mysql
</code></pre></div><p>I don&rsquo;t have, nor do I want to install, a MySQL client (visual or otherwise) on my pristine laptop. So how are do we get the schema and data into our MySQL container running on Docker? The answer is to run whatever commands we need using another MySQL Docker container linked to our &lsquo;server instance&rsquo;. Instructions on how to do this are outlined in the section <strong>Connect to MySQL from the MySQL command line client</strong> on the <a href=https://registry.hub.docker.com/_/mysql/>MySQL Docker image</a> page in the official Docker registry.</p><p>Now create the schema that our application is going to use:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker run -it --link mysql:mysql --rm mysql sh -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>   <span style=color:#e6db74>&#39;exec mysql -h&#34;$MYSQL_PORT_3306_TCP_ADDR&#34; \
</span><span style=color:#e6db74>   -P&#34;$MYSQL_PORT_3306_TCP_PORT&#34; -uroot \
</span><span style=color:#e6db74>   -p&#34;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&#34; \
</span><span style=color:#e6db74>   -e &#34;create schema my-schema&#34;&#39;</span><span style=color:#e6db74>`</span>
</code></pre></div><p>Check that the database was created:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker run -it --link mysql:mysql --rm mysql sh -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#e6db74>&#39;exec mysql -h&#34;$MYSQL_PORT_3306_TCP_ADDR&#34; \
</span><span style=color:#e6db74>    -P&#34;$MYSQL_PORT_3306_TCP_PORT&#34; -uroot \
</span><span style=color:#e6db74>    -p&#34;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&#34; \
</span><span style=color:#e6db74>    -e &#34;show databases&#34;&#39;</span>
Warning: Using a password on the command line interface can be insecure.
+--------------------+
| Database           |
+--------------------+
| information_schema |
| my-schema          |
| mysql              |
| performance_schema |
+--------------------+
</code></pre></div><p>Next I want to take a snapshot of the production database:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker run -it -v /Users/awolski/Downloads:/tmp <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>   --rm mysql sh -c <span style=color:#e6db74>&#39;exec mysqldump -h&lt;production_db_ip&gt; \
</span><span style=color:#e6db74>   -uusername -p &lt;production_schema&gt; &gt; /tmp/my-schema.sql&#39;</span>
Enter password:
</code></pre></div><p>And then import my snapshot into the new schema I created, mounting the directory I exported the production schema to as a volume:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker run -it -v /Users/awolski/Downloads:/tmp <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>   --link mysql:mysql --rm mysql sh -c <span style=color:#e6db74>&#39;exec mysql \
</span><span style=color:#e6db74>   -h&#34;$MYSQL_PORT_3306_TCP_ADDR&#34; \
</span><span style=color:#e6db74>   -P&#34;$MYSQL_PORT_3306_TCP_PORT&#34; -uroot \
</span><span style=color:#e6db74>   -p&#34;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&#34; \
</span><span style=color:#e6db74>   my-schema &lt; /tmp/my-schema.sql&#39;</span>
</code></pre></div><p>I can verify that everything worked by showing the new tables:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ docker run -it --link mysql:mysql --rm mysql sh -c <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>   <span style=color:#e6db74>&#39;exec mysql -h&#34;$MYSQL_PORT_3306_TCP_ADDR&#34; \
</span><span style=color:#e6db74>   -P&#34;$MYSQL_PORT_3306_TCP_PORT&#34; -uroot \
</span><span style=color:#e6db74>   -p&#34;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&#34; \
</span><span style=color:#e6db74>   -e &#34;use my-schema; show tables;&#34;&#39;</span>
</code></pre></div><p>(I&rsquo;ve omitted the output for brevity).</p><p>There you have it&mldr; point your application at the ip output by <code>docker-machine ip</code> and you&rsquo;re away, coding against a production-like database.</p><p>Obviously you don&rsquo;t want to run all of these commands every time you need to start from scratch. And let&rsquo;s be honest, who&rsquo;s going to remember all of those environment variables anyway. So best to create a script to replicate it, using a few arguments for customisation. But I&rsquo;ll leave that as a task for the reader!</p><footer>&#171; <a href=https://awolski.com/considering-microservices/>Previous</a>
||
<a href=https://awolski.com/stormpath-java-sdk-behind-a-proxy-using-shiro-jndiobjectfactory/>Next</a> &#187;</footer></article><div id=comments><strong>Your thoughts?</strong> I'd love to hear them. Please get in <a href=/contact>contact</a>.</div></div></body></html>